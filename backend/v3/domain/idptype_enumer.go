// Code generated by "enumer -type IDPType -transform lower -trimprefix IDPType -sql"; DO NOT EDIT.

package domain

import (
	"database/sql/driver"
	"fmt"
	"strings"
)

const _IDPTypeName = "unspecifiedoidcjwtoauthsamlldapgithubgithubenterprisegitlabgitlabselfhostedazuregoogleapple"

var _IDPTypeIndex = [...]uint8{0, 11, 15, 18, 23, 27, 31, 37, 53, 59, 75, 80, 86, 91}

const _IDPTypeLowerName = "unspecifiedoidcjwtoauthsamlldapgithubgithubenterprisegitlabgitlabselfhostedazuregoogleapple"

func (i IDPType) String() string {
	if i >= IDPType(len(_IDPTypeIndex)-1) {
		return fmt.Sprintf("IDPType(%d)", i)
	}
	return _IDPTypeName[_IDPTypeIndex[i]:_IDPTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _IDPTypeNoOp() {
	var x [1]struct{}
	_ = x[IDPTypeUnspecified-(0)]
	_ = x[IDPTypeOIDC-(1)]
	_ = x[IDPTypeJWT-(2)]
	_ = x[IDPTypeOAuth-(3)]
	_ = x[IDPTypeSAML-(4)]
	_ = x[IDPTypeLDAP-(5)]
	_ = x[IDPTypeGitHub-(6)]
	_ = x[IDPTypeGitHubEnterprise-(7)]
	_ = x[IDPTypeGitLab-(8)]
	_ = x[IDPTypeGitLabSelfHosted-(9)]
	_ = x[IDPTypeAzure-(10)]
	_ = x[IDPTypeGoogle-(11)]
	_ = x[IDPTypeApple-(12)]
}

var _IDPTypeValues = []IDPType{IDPTypeUnspecified, IDPTypeOIDC, IDPTypeJWT, IDPTypeOAuth, IDPTypeSAML, IDPTypeLDAP, IDPTypeGitHub, IDPTypeGitHubEnterprise, IDPTypeGitLab, IDPTypeGitLabSelfHosted, IDPTypeAzure, IDPTypeGoogle, IDPTypeApple}

var _IDPTypeNameToValueMap = map[string]IDPType{
	_IDPTypeName[0:11]:       IDPTypeUnspecified,
	_IDPTypeLowerName[0:11]:  IDPTypeUnspecified,
	_IDPTypeName[11:15]:      IDPTypeOIDC,
	_IDPTypeLowerName[11:15]: IDPTypeOIDC,
	_IDPTypeName[15:18]:      IDPTypeJWT,
	_IDPTypeLowerName[15:18]: IDPTypeJWT,
	_IDPTypeName[18:23]:      IDPTypeOAuth,
	_IDPTypeLowerName[18:23]: IDPTypeOAuth,
	_IDPTypeName[23:27]:      IDPTypeSAML,
	_IDPTypeLowerName[23:27]: IDPTypeSAML,
	_IDPTypeName[27:31]:      IDPTypeLDAP,
	_IDPTypeLowerName[27:31]: IDPTypeLDAP,
	_IDPTypeName[31:37]:      IDPTypeGitHub,
	_IDPTypeLowerName[31:37]: IDPTypeGitHub,
	_IDPTypeName[37:53]:      IDPTypeGitHubEnterprise,
	_IDPTypeLowerName[37:53]: IDPTypeGitHubEnterprise,
	_IDPTypeName[53:59]:      IDPTypeGitLab,
	_IDPTypeLowerName[53:59]: IDPTypeGitLab,
	_IDPTypeName[59:75]:      IDPTypeGitLabSelfHosted,
	_IDPTypeLowerName[59:75]: IDPTypeGitLabSelfHosted,
	_IDPTypeName[75:80]:      IDPTypeAzure,
	_IDPTypeLowerName[75:80]: IDPTypeAzure,
	_IDPTypeName[80:86]:      IDPTypeGoogle,
	_IDPTypeLowerName[80:86]: IDPTypeGoogle,
	_IDPTypeName[86:91]:      IDPTypeApple,
	_IDPTypeLowerName[86:91]: IDPTypeApple,
}

var _IDPTypeNames = []string{
	_IDPTypeName[0:11],
	_IDPTypeName[11:15],
	_IDPTypeName[15:18],
	_IDPTypeName[18:23],
	_IDPTypeName[23:27],
	_IDPTypeName[27:31],
	_IDPTypeName[31:37],
	_IDPTypeName[37:53],
	_IDPTypeName[53:59],
	_IDPTypeName[59:75],
	_IDPTypeName[75:80],
	_IDPTypeName[80:86],
	_IDPTypeName[86:91],
}

// IDPTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func IDPTypeString(s string) (IDPType, error) {
	if val, ok := _IDPTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _IDPTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to IDPType values", s)
}

// IDPTypeValues returns all values of the enum
func IDPTypeValues() []IDPType {
	return _IDPTypeValues
}

// IDPTypeStrings returns a slice of all String values of the enum
func IDPTypeStrings() []string {
	strs := make([]string, len(_IDPTypeNames))
	copy(strs, _IDPTypeNames)
	return strs
}

// IsAIDPType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i IDPType) IsAIDPType() bool {
	for _, v := range _IDPTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

func (i IDPType) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *IDPType) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of IDPType: %[1]T(%[1]v)", value)
	}

	val, err := IDPTypeString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
